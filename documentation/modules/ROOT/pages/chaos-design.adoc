:markup-in-source: verbatim,attributes,quotes
:CHE_URL: http://codeready-workspaces.%APPS_HOSTNAME_SUFFIX%
:USER_ID: %USER_ID%
:OPENSHIFT_PASSWORD: %OPENSHIFT_PASSWORD%
:OPENSHIFT_CONSOLE_URL: https://console-openshift-console.%APPS_HOSTNAME_SUFFIX%/topology/ns/chaos-engineering{USER_ID}/graph
:APPS_HOSTNAME_SUFFIX: %APPS_HOSTNAME_SUFFIX%
:KIALI_URL: https://kiali-istio-system.%APPS_HOSTNAME_SUFFIX%
:GRAFANA_URL: https://grafana-istio-system.%APPS_HOSTNAME_SUFFIX%

= Design Chaos experiments

_XX MINUTE PRACTICE_

According to the Principles of Chaos Engineering (
    https://principlesofchaos.org/[https://principlesofchaos.org/])
    
**Chaos Engineering** is the discipline of experimenting on a system in order to build confidence in the system's capability to withstand turbulent conditions in production.
**Chaos engineering**'s sole purpose is to provide evidence of system weaknesses (sometimes called https://snafucatchers.github.io/#4_6_Dark_Debt[Dark Debt])

Take an example where you have two services that communicate with each other. 

image::simple-2-service.png[simple-2-service - A simple two-service system, 800]


What should happen if **Service Y** dies ? What will happen to **Service X** if **Service Y** starts to respond slowly ? what happens if **Service Y** comes back after going away for a period of time? what happens is the connection between **Service X** and Y becomes increasingly busy ? What happens if the CPU that is being used by **Service Y** is maxed out ? and most importanlty, what does this all men to the user ?

You might believe you've designed the services and the infrastructure perfectly to accomodate all of these cases, but how to you know ? Even in such a simple system it is likely tere might be some surprises --some **dark debt** -- present. **Chaos engineering** provides a way of exploring these uncertainties to find out whether your assumptions of the system's resiliency hold water in the real world.


== Plan an Experiment

Chaos Engineering begins by asking the question : 

**"Do we know what the system might do in this case ?"**


image::process-chaos.png[process-chaos, 800]

The general process for chaos engineering looks as follows:

* **Define a steady-state hypothesis:** You need to start with an idea of what can go awry. Start with a failure to inject and predict an outcome for when it is running live.

* **Confirm the steady-state and simulate some real-world events:** Perform tests using real-world scenarios to see how your system behaves under particular stress conditions or circumstances.

* **Confirm the steady-state again:** We need to confirm what changes occurred, so checking it again gives us insights into system behavior.

* **Collect metrics and observe dashboards:** You need to measure your system’s durability and availability. It is best practice to use key performance metrics that correlate with customer success or usage. We want to measure the failure against our hypothesis by looking at factors like impact on latency or requests per second.

* **Make changes and fix issues:** After running an experiment, you should have a good idea of what is working and what needs to be altered. Now we can identify what will lead to an outage, and we know exactly what breaks the system. So, go fix it, and try again with a new experiment.


image::chaos-engineering-process.png[chaos-engineering-process, 800]


Later on this workshop we will use **Openshift Service Mesh** to inject failures in our **Expriment**

== What is OpenShift Service Mesh?
[sidebar]
--
**OpenShift Service Mesh** is also a service available on top of OpenShift.

As applications evolve into collections of decentralized services, managing communications and security between those services becomes more difficult. 

**Red Hat OpenShift Service Mesh** provides a uniform way to connect, manage, and observe microservices-based applications.
--

What’s in **Red Hat OpenShift Service Mesh** ?


[tabs]
====
Istio::
+
--
**Istio** is an open-source project for integrating and managing traffic flow across services. It works in concert with an underlying cluster manager (like Kubernetes). Centralized components, sidecar proxies, and node agents work together to create the data and control planes over a distributed application.
--
Tracing::
+
--
Tracing allows you to track a single request as it makes its way between different services - or even inside a service - providing insight into the entire request process from start to finish. OpenShift service mesh uses **Jaeger**, an open, distributed tracing system.
--
Visualization::
+
--
Visualization helps users see communication pathways between services, how they’re being managed, and how traffic is flowing in near-real time for easier management and troubleshooting. OpenShift service mesh uses **Kiali**, an open source project, to view configuration, monitor traffic, and analyze traces.
--
====


In this Workshop we are focusing on **KIALI** - The VISUALIZATION part of ** Red Hat Openshift Service Mesh**

== Observability with Kiali

**Kiali** provides an interactive graph view of your namespace in real time, being able to display the interactions at several levels (applications, versions, workloads), with contextual information and charts on the selected graph node or edge.

`*Click on the 'Developer Observability' button below*`

[link={KIALI_URL}]
[window=_blank, align="center"]
[role='params-link']
image::developer-observability-button.png[Developer Observability - Button, 300]

Then, `*log in with OpenShift as user{USER_ID}/{OPENSHIFT_PASSWORD}'*`

image::kiali-login.png[Kiali- Log In,300]

In the **'Graph' view**, `*enter the following configuration*`:

.Graph Settings
[%header,cols=2*]
|===
|Parameter
|Value

|Namespace 
|**chaos-engineering{USER_ID}**

|Type Graph
|**Versioned app graph**

|Display
|**'Response Time'** checked

**'Traffic Animation'** checked

|Hide...
|**service*=svc.cluster.local**

|===

The outcome is a graph with all the services, connected by the requests going through them. 
You can see how the services interact with each other. 

image::kiali-graph.png[Kiali- Graph,900]

== Application description

Before to continue we will describe the application used in this workshop.

This demo application will deploy several services into 1 namespace.

* **'chaos-engineering{USER_ID}'** namespace

Inside the **'chaos-engineering{USER_ID}' namespace** we can discover 3 parts 

* Travel-portal
* Travel-agency
* Travel-control 

image::Application-travel-description.png[Application Travel Description- Graph,900]


The Travels Demo application simulates two business domains 

In a first part called **Travel-portal** there will be deployed several travel shops, where users can search for and book flights, hotels, cars or insurance.

The shop applications can behave differently based on request characteristics like channel (web or mobile) or user (new or existing).

These workloads may generate different types of traffic to imitate different real scenarios.

All the portals consume a service called travels.

**Travel Agency **

A second part called **travel-agency** will host a set of services created to provide quotes for travel.

A main travels service will be the business entry point for the travel agency. It receives a destination city and a user as parameters and it calculates all elements that compose a travel budget: airfare, lodging, car reservation and travel insurance.

Each service can provide an independent quote and the travels service must then aggregate them into a single response.

Additionally, some users, like registered users, can have access to special discounts, managed as well by an external service.

Service relations between services of the applications can be described in the following diagram:

image::travels-demo-design.png[travel-demo-design - Travel demo Project deployed by Argo CD , 800]

**Travel Portal and Travel Agency flow**

A typical flow consists of the following steps:

<.> A portal queries the travels service for available destinations.

<.> Travels service queries the available hotels and returns to the portal shop.

<.> A user selects a destination and a type of travel, which may include a flight and/or a car, hotel and insurance.

<.> Cars, Hotels and Flights may have available discounts depending on user type.

**Travel Control**

The **Travel-Control**  runs a **business dashboard** with two key features:

* Allow setting changes for every travel shop simulator (traffic ratio, device, user and type of travel).

* Provide a **business** view of the total requests generated from the **travel-control** service to the **travel-agency** services, organized by business criteria as grouped per shop, per type of traffic and per city.

image::travels-dashboard.png[travels-dashboard - Business Dashboard , 800]
