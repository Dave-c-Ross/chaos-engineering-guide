:markup-in-source: verbatim,attributes,quotes
:CHE_URL: http://codeready-workspaces.%APPS_HOSTNAME_SUFFIX%
:USER_ID: %USER_ID%
:OPENSHIFT_PASSWORD: %OPENSHIFT_PASSWORD%
:OPENSHIFT_CONSOLE_URL: https://console-openshift-console.%APPS_HOSTNAME_SUFFIX%/topology/ns/chaos-engineering{USER_ID}/graph

:APPS_HOSTNAME_SUFFIX: %APPS_HOSTNAME_SUFFIX%

= Run Chaos testing

_XX MINUTE PRACTICE_

== Plan an Experiment

== What is OpenShift Service Mesh?
[sidebar]
--
**OpenShift Service Mesh** is also a service available on top of OpenShift.

As applications evolve into collections of decentralized services, managing communications and security between those services becomes more difficult. 

**Red Hat OpenShift Service Mesh** provides a uniform way to connect, manage, and observe microservices-based applications.
--

What’s in **Red Hat OpenShift Service Mesh** ?

[tabs]
====
Istio::
+
--
**Istio** is an open-source project for integrating and managing traffic flow across services. It works in concert with an underlying cluster manager (like Kubernetes). Centralized components, sidecar proxies, and node agents work together to create the data and control planes over a distributed application.
--
Tracing::
+
--
Tracing allows you to track a single request as it makes its way between different services - or even inside a service - providing insight into the entire request process from start to finish. OpenShift service mesh uses **Jaeger**, an open, distributed tracing system.
--
Visualization::
+
--
Visualization helps users see communication pathways between services, how they’re being managed, and how traffic is flowing in near-real time for easier management and troubleshooting. OpenShift service mesh uses **Kiali**, an open source project, to view configuration, monitor traffic, and analyze traces.
--
====

== Observability with Kiali

**Kiali** provides an interactive graph view of your namespace in real time, being able to display the interactions at several levels (applications, versions, workloads), with contextual information and charts on the selected graph node or edge.

`*Click on the 'Developer Observability' button below*`

[link={KIALI_URL}]
[window=_blank, align="center"]
[role='params-link']
image::developer-observability-button.png[Developer Observability - Button, 300]

Then, `*log in with OpenShift as user{USER_ID}/{OPENSHIFT_PASSWORD}'*`

image::kiali-login.png[Kiali- Log In,300]

In the **'Graph' view**, `*enter the following configuration*`:

.Graph Settings
[%header,cols=2*]
|===
|Parameter
|Value

|Namespace 
|**chaos-engineering{USER_ID}**

|Type Graph
|**Versioned app graph**

|Display
|**'Response Time'** checked

**'Traffic Animation'** checked

|Hide...
|**service*=svc.cluster.local**

|===

The outcome is a graph with all the services, connected by the requests going through them. 
You can see how the services interact with each other. 

image::kiali-graph.png[Kiali- Graph,900]


**TODO: EXPLAIN THE APPLICATION**

== Chaos Experiment 1: Injecting latencies

In production, it is very common to have delay services rather than down services.

_How Travels Service will behave when one of its dependant services experiment network latencies?_


== Chaos Experiment 2: Injecting incidents

== Solve detected issues